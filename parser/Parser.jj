
options
{
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  USER_TOKEN_MANAGER = false;
}

PARSER_BEGIN(ProgramParser)
package parser;
//import path_to_packages;
import org.jgraph.graph.DefaultEdge;
import org.jgrapht.DirectedGraph;
import org.jgrapht.graph.SimpleDirectedGraph;
import org.jgrapht.graph.SimpleGraph;
import java.util.Stack;
import structures.*;

public final class ProgramParser
{
  // the graph to parse
  private static DirectedGraph<Vertex,Edge> graph;
  private static Stack<Vertex> stack;
  private static StringBuffer outputDot;
  private static int lineNumber;
  

  private static void initVariables (){
  	// TODO 
  }
  
  private static void writeGraph(Vertex a , Vertex b){
  
  	outputDot.append("\""+a.getNum()+". "+a.getLine()+"\""+ "  ->  " + "\""+b.getNum()+". "+b.getLine() +"\""+ "\n");
  
  }
  

  /** init or reinit the parser
  ** to be used when one wants to read part of a program */
  public static void init(java.io.Reader in)
  {
    // init the enum and ID creator

    if (token_source == null)
    	new ProgramParser(in);
    else
    	ReInit(in);
  }
}
PARSER_END(ProgramParser)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

TOKEN :
{
  < EQ : "==" >
| < LT : "<" >
| < LE : "<=" >
| < GT : ">" >
| < GE : ">=" >
| < NEQ : "!=" >
| < AND :    "AND"  | "and" >
| < OR : "OR" | "or" >
| < NOT : "NOT" | "not" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULT : "*" >
| < DIV : "/" >
| < NUMBER : ("-")? ([ "0"-"9" ])+ >
| < COMMENT : "//" (~[ "\n" ])+ "\n" >
| < TRUE :    "true"  | "TRUE" >
| < FALSE :    "false"  | "FALSE" >
}


public void parseProgram(DirectedGraph g,StringBuffer dotFile) :
{
  Token token;
  String name;
  outputDot = dotFile;  
  graph = g;
  initVariables();
  stack = new Stack<Vertex>();
  lineNumber = 0;
}
{
    {Vertex begin = new Vertex("begin",VertexType.BEGIN);
    	graph.addVertex(begin);
    	
     	stack.push(begin);
     	System.out.println(stack.empty());
     }
	statement()
	{
		
		//System.out.println(out);
	}
  
}


private void statement() :
{
String out;
}
{
	(
		out = assignmentStatement() {
										Vertex assign = new Vertex(out,VertexType.ASSIGN);
										Vertex top = stack.peek();
										//System.out.println(top);
									    if(!top.isCond() && !top.isDo()) // the previous assignment can be dropped
									   		top = stack.pop();
									    graph.addVertex(assign);
										graph.addEdge(top, assign);
										//outputDot = outputDot + top.getLine() + "->" + assign.getLine() + ";\n";
										writeGraph(top,assign);  
										stack.push(assign);
										//System.out.println("add assign to graph ");
									}
	| 
		ifStatement()	{
							System.out.println("add assign to graph ");
						}
	|
		whileStatement()	{ 
								System.out.println("add assign to graph ");
							}
	)+
}


String assignmentStatement() :
{
String id,exp;
}
{
	id = ID() "=" exp = mathExpression() ";" { System.out.println( "; exp : "+exp ); }
	{
		return id + " = " + exp + ";" ;
	}
}

private void ifStatement() :
{
String e;
Vertex s1, s2, cond;

}
{
	"if" "(" e = logicExpression() ")"	{	cond = new Vertex(e,VertexType.COND);
											System.out.println("Numero vertice : "+cond.getNum());
			  						    	Vertex top = stack.peek();
									    	if(!top.isCond() && !top.isDo() )
									   			top = stack.pop();
									   		graph.addVertex(cond);
									   		Edge ed = graph.addEdge(top,cond);
									   		writeGraph(top,cond);
									   		ed.setLabel(e);
								   			stack.push(cond);
								   		}
	 "then" "{" statement() "}"		{	s1 = stack.peek();
	 									while (!stack.peek().isCond() && !top.isDo() ) {
											stack.pop();
										}
									} 
	 "else" "{" statement() "}"		{	s2 = stack.peek();
	 									while (!stack.peek().isCond() && !top.isDo() ) {
	 										stack.pop();
	 									}
	 									cond = stack.pop(); // delete condition
	 									Vertex join= new Vertex("join",VertexType.JOIN);
	 									graph.addVertex(join);
	 									graph.addEdge(s1,join);
	 									graph.addEdge(s2,join);
	 									writeGraph(s1,join);
	 									writeGraph(s2,join);
	 									stack.push(join);
	 								} 
}


private void whileStatement() :
{
String s,e;
Vertex dov, cond, top;
Edge edge;

}
{
	"do" 								{dov = new Vertex("do",VertexType.DO);
										
										top = stack.peek();
										System.out.println(top.getNum()+" "+top);
										System.out.println("DOOO "+top);
										
									    if(!top.isCond() && !top.isDo()) // the previous assignment can be dropped
									   		top = stack.pop();
										
										graph.addVertex(dov);
										graph.addEdge(top,dov);
										writeGraph(top,dov);
										
										stack.push(dov);
										} 
	"{" statement() "}"
	"while" "(" e = logicExpression() ")"
										{
											cond = new Vertex(e,VertexType.COND);
											top = stack.peek();
									    	if(!top.isCond() && !top.isDo() )
									   			top = stack.pop();
									   		graph.addVertex(cond);
									   		
									   		
									   		Edge ed = graph.addEdge(top,cond);
									   		
									   		writeGraph(top,cond);
									   		ed.setLabel(e);
									   		
									   		top = stack.peek();
	 										while (!top.isDo() ) {
	 											top = stack.pop();
	 										}
									   		dov = stack.peek();
									   		edge = graph.addEdge(cond,dov);
									   		writeGraph(cond,dov);
									   		edge.setLabel(e);
									   		
								   			stack.push(cond);
										} 
}

String logicExpression() :
{
String e = "";
String e2 = "";
String op = "";
Token token;
}
{
	(
		token = <TRUE> {op = token.image;}
	|
		token = <FALSE> {op = token.image;}
	|
		e = mathElement() [
		(
		token = <NEQ> e2 = mathElement()
		| token = <EQ> e2 = mathElement()
		| token = <LT> e2 = mathElement()
		| token = <LE> e2 = mathElement()
		| token = <GT> e2 = mathElement()
		| token = <GE> e2 = mathElement()
		)
		{op = token.image;}
		]
	)
	
	{	System.out.println("logicExpresion : "+e+op+e2);
		return e + op + e2 ;
	}

}


// math Expression
// + 
String mathExpression() :
{
  String e, e2;
}
{
  e = mathElement() [< PLUS > e2 = mathElement() { System.out.println(" PLUS" + e2) ; e = e + " + " + e2; } ]
  {
	return e;
  }
}


String mathElement() :
{
  Token t;  
  String id;
}
{
  (
    t = < NUMBER >
    {
    System.out.println(" Number : "+ t.image);
      return t.image;
    }
  | id = ID()
    {
    System.out.println(" ID : "+ id );    
      return id;
    }  
  )
}

String ID() :
{
  Token t;
}
{
  t = < ID >
  {
    return t.image;
  }
}


TOKEN :
{
	< ID : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
}
